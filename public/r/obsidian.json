{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "obsidian",
  "type": "registry:ui",
  "title": "Obsidian",
  "description": "A fully interactive clone of the popular UI Library Obsidian for Next.js, React and TailwindCSS.",
  "dependencies": [
    "dompurify"
  ],
  "registryDependencies": [
    "tabs"
  ],
  "files": [
    {
      "path": "src/components/obsidian/DynamicTab.tsx",
      "content": "import { memo, useMemo, FC } from \"react\";\n\nimport { TabData, UIElement, Addons } from \"./element.types\";\nimport { Groupbox } from \"./elements/GroupBox\";\nimport { TabContainer, TabLeft, TabRight } from \"./elements/Tab\";\nimport Divider from \"./elements/Divider\";\nimport Toggle from \"./elements/Toggle\";\nimport Button from \"./elements/Button\";\nimport ObsidianImage from \"./elements/Image\";\nimport Label from \"./elements/Label\";\nimport Tabbox from \"./elements/TabBox\";\nimport Dropdown from \"./elements/Dropdown\";\nimport Input from \"./elements/Input\";\nimport Slider from \"./elements/Slider\";\nimport KeyPicker from \"./elements/addons/KeyPicker\";\nimport AddonContainer from \"./elements/addons/AddonContainer\";\nimport ColorPicker from \"./elements/addons/ColorPicker\";\nimport ObsidianWarningBox from \"./elements/WarningBox\";\n\n// Parsers //\nconst renderAddons = (\n  element: UIElement,\n  addons?: Addons[],\n  stateKeyPrefix?: string\n) => {\n  if (!addons || addons.length === 0) return null;\n\n  const scope = stateKeyPrefix || \"global\";\n  return (\n    <AddonContainer className=\"absolute inset-0 pointer-events-none\">\n      {addons.map((addon, idx) => {\n        const addonKey = `${scope}:addon:${addon.type}:${element.index}:${idx}`;\n\n        switch (addon.type) {\n          case \"KeyPicker\":\n            return (\n              <KeyPicker\n                key={idx}\n                defaultValue={addon.value}\n                className=\"pointer-events-auto\"\n                stateKey={addonKey}\n              />\n            );\n\n          case \"ColorPicker\":\n            return (\n              <ColorPicker\n                key={idx}\n                title={addon.title}\n                defaultValue={addon.value}\n                className=\"pointer-events-auto\"\n                stateKey={addonKey}\n              />\n            );\n\n          default:\n            return null;\n        }\n      })}\n    </AddonContainer>\n  );\n};\n\nexport const ElementParser: FC<{\n  element: UIElement;\n  stateKeyPrefix?: string;\n}> = ({ element, stateKeyPrefix }) => {\n  if (\"visible\" in element && !element.visible) return null;\n\n  const scope = stateKeyPrefix || \"global\";\n  const addons = (element as unknown as { properties?: { addons?: Addons[] } })\n    .properties?.addons;\n  const core = (() => {\n    switch (element.type) {\n      case \"Toggle\":\n        return (\n          <Toggle\n            text={element.text}\n            risky={element.properties.risky}\n            checked={element.value}\n            stateKey={`${scope}:el:Toggle:${element.index}`}\n          />\n        );\n\n      case \"Label\":\n        return <Label>{element.text}</Label>;\n\n      case \"Button\":\n        return <Button text={element.text} subButton={element.subButton} />;\n\n      case \"Dropdown\":\n        return (\n          <Dropdown\n            text={element.text}\n            value={element.value}\n            options={element.properties.values}\n            multi={element.properties.multi === true}\n            disabledValues={element.properties.disabledValues || []}\n            stateKey={`${scope}:el:Dropdown:${element.index}`}\n          />\n        );\n\n      case \"Slider\":\n        return (\n          <Slider\n            text={element.text}\n            value={element.value}\n            min={element.properties.min}\n            max={element.properties.max}\n            compact={element.properties.compact}\n            rounding={element.properties.rounding}\n            prefix={element.properties.prefix}\n            suffix={element.properties.suffix}\n            stateKey={`${scope}:el:Slider:${element.index}`}\n          />\n        );\n\n      case \"Input\":\n        return (\n          <Input\n            text={element.text}\n            value={element.value}\n            placeholder={element.properties.placeholder}\n            stateKey={`${scope}:el:Input:${element.index}`}\n          />\n        );\n\n      case \"Divider\":\n        return <Divider />;\n\n      case \"Image\":\n        return (\n          <ObsidianImage\n            image={element.properties.image}\n            transparency={element.properties.transparency}\n            scaleType={element.properties.scaleType}\n            color={element.properties.color}\n            rectOffset={element.properties.rectOffset}\n            height={element.properties.height}\n            rectSize={element.properties.rectSize}\n          />\n        );\n\n      default:\n        return (\n          <div className=\"text-red-400 text-left\">\n            Unknown element type:{\" \"}\n            {(element as { type: string }).type || \"Unknown\"}\n          </div>\n        );\n    }\n  })();\n\n  return (\n    <div className=\"relative\">\n      {core}\n      {renderAddons(element, addons, stateKeyPrefix)}\n    </div>\n  );\n};\n\nconst TabParserComponent: FC<{ tabData: TabData | null }> = ({ tabData }) => {\n  const { groupboxes, tabboxes, warningBox } = tabData || {};\n\n  const leftGroupboxes = useMemo(\n    () =>\n      groupboxes?.Left\n        ? Object.values(groupboxes.Left).sort(\n            (a, b) => (a.order ?? 0) - (b.order ?? 0)\n          )\n        : [],\n    [groupboxes?.Left]\n  );\n\n  const rightGroupboxes = useMemo(\n    () =>\n      groupboxes?.Right\n        ? Object.values(groupboxes.Right).sort(\n            (a, b) => (a.order ?? 0) - (b.order ?? 0)\n          )\n        : [],\n    [groupboxes?.Right]\n  );\n\n  const leftTabboxes = useMemo(\n    () => (tabboxes?.Left ? Object.values(tabboxes.Left) : []),\n    [tabboxes?.Left]\n  );\n\n  const rightTabboxes = useMemo(\n    () => (tabboxes?.Right ? Object.values(tabboxes.Right) : []),\n    [tabboxes?.Right]\n  );\n\n  if (!tabData) return null;\n\n  return (\n    <>\n      {warningBox && (\n        <ObsidianWarningBox\n          text={warningBox.Text}\n          title={warningBox.Title}\n          visible={warningBox.Visible}\n          isNormal={warningBox.IsNormal}\n          lockSize={warningBox.LockSize}\n        />\n      )}\n      <TabContainer>\n        <TabLeft>\n          {leftTabboxes.map((tabbox) => (\n            <Tabbox\n              key={tabbox.name}\n              tabs={tabbox.tabs}\n              scope={`tab:${tabData.name}:left:tabbox:${tabbox.name}`}\n            />\n          ))}\n          {leftGroupboxes.map((gb) => (\n            <Groupbox key={gb.name} title={gb.name}>\n              {gb.elements.map((el) => (\n                <ElementParser\n                  key={`left-gb-${gb.name}-${el.index}`}\n                  element={el}\n                  stateKeyPrefix={`gb:${tabData.name}:left:groupbox:${gb.name}`}\n                />\n              ))}\n            </Groupbox>\n          ))}\n        </TabLeft>\n        <TabRight>\n          {rightTabboxes.map((tabbox) => (\n            <Tabbox\n              key={tabbox.name}\n              tabs={tabbox.tabs}\n              scope={`tab:${tabData.name}:right:tabbox:${tabbox.name}`}\n            />\n          ))}\n          {rightGroupboxes.map((gb) => (\n            <Groupbox key={gb.name} title={gb.name}>\n              {gb.elements.map((el) => (\n                <ElementParser\n                  key={`right-gb-${gb.name}-${el.index}`}\n                  element={el}\n                  stateKeyPrefix={`gb:${tabData.name}:right:groupbox:${gb.name}`}\n                />\n              ))}\n            </Groupbox>\n          ))}\n        </TabRight>\n      </TabContainer>\n    </>\n  );\n};\n\nTabParserComponent.displayName = \"TabParser\";\nexport const TabParser = memo(TabParserComponent);\n",
      "type": "registry:ui",
      "target": "components/obsidian/DynamicTab.tsx"
    },
    {
      "path": "src/components/obsidian/UIStateProvider.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport type { ReactNode } from \"react\";\n\ntype UIState = Record<string, unknown>;\n\ntype UIStateContextType = {\n\tstate: Readonly<UIState>;\n\tsetState: (key: string, value: unknown) => void;\n\tresetState: (prefix?: string) => void;\n\tsubscribe: (key: string, callback: () => void) => () => void;\n\tget: (key: string) => unknown;\n};\n\nconst UIStateContext = React.createContext<UIStateContextType | null>(null);\n\nexport function UIStateProvider({ children }: { children: ReactNode }) {\n\tconst [state, setStateMap] = React.useState<UIState>({});\n\tconst stateRef = React.useRef<UIState>({});\n\n\tconst listenersRef = React.useRef<Map<string, Set<() => void>>>(new Map());\n\tconst notify = React.useCallback((key: string) => {\n\t\tconst set = listenersRef.current.get(key);\n\t\tif (!set) return;\n\t\tfor (const cb of Array.from(set)) {\n\t\t\ttry { cb(); }\n\t\t\tcatch (err) {\n\t\t\t\tif (process.env.NODE_ENV !== \"production\") {\n\t\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\t\tconsole.error(\"[UIState.notify] listener threw:\", err);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}, []);\n\n\tconst setState = React.useCallback((key: string, value: unknown) => {\n\t\tconst prev = (stateRef.current as Record<string, unknown>)[key];\n\t\tif (Object.is(prev, value)) return;\n\n\t\tconst next = { ...stateRef.current, [key]: value };\n\t\tstateRef.current = next;\n\t\tsetStateMap(next);\n\t\tnotify(key);\n\t}, [notify]);\n\n\tconst resetState = React.useCallback((prefix?: string) => {\n\t\tif (prefix === undefined) {\n\t\t\t// notify all keys //\n\t\t\tstateRef.current = {};\n\t\t\tsetStateMap({});\n\t\t\tfor (const key of listenersRef.current.keys()) notify(key);\n\t\t\treturn;\n\t\t}\n\n\t\tconst prev = stateRef.current;\n\t\tconst next: UIState = {};\n\t\tfor (const [k, v] of Object.entries(prev)) {\n\t\t\tif (!k.startsWith(prefix)) next[k] = v;\n\t\t}\n\n\t\t// notify keys under the prefix //\n\t\tstateRef.current = next;\n\t\tsetStateMap(next);\n\t\tfor (const key of listenersRef.current.keys()) {\n\t\t\tif (key.startsWith(prefix)) notify(key);\n\t\t}\n\t}, [notify]);\n\n\tconst subscribe = React.useCallback((key: string, callback: () => void) => {\n\t\tlet listeners = listenersRef.current.get(key);\n\t\tif (!listeners) {\n\t\t\tlisteners = new Set();\n\t\t\tlistenersRef.current.set(key, listeners);\n\t\t}\n\n\t\tlisteners.add(callback);\n\t\treturn () => {\n\t\t\tlisteners?.delete(callback);\n\t\t\tif (listeners && listeners.size === 0) listenersRef.current.delete(key);\n\t\t};\n\t}, []);\n\n\tconst get = React.useCallback((key: string) => stateRef.current[key], []);\n\n\treturn (\n\t\t<UIStateContext.Provider value={{ state, setState, resetState, subscribe, get }}>\n\t\t\t{children}\n\t\t</UIStateContext.Provider>\n\t);\n}\n\nexport function useUIState() {\n\tconst ctx = React.useContext(UIStateContext);\n\tif (!ctx) throw new Error(\"useUIState must be used within UIStateProvider\");\n\treturn ctx;\n}\n\nexport function useResetUIState() {\n\tconst { resetState } = useUIState();\n\treturn resetState;\n}\n\nexport function useUIValue<T = unknown>(key: string | undefined, initialValue?: T): [T | undefined, (value: T | ((prev: T | undefined) => T)) => void] {\n\tconst ctx = React.useContext(UIStateContext);\n\tif (!ctx) throw new Error(\"useUIValue must be used within UIStateProvider\");\n\n\tconst { setState, subscribe, get } = ctx;\n\n\tconst getSnapshot = React.useCallback(() => {\n\t\tif (!key) return initialValue as T | undefined;\n\t\treturn (get(key) as T | undefined) ?? (initialValue as T | undefined);\n\t}, [get, key, initialValue]);\n\n\tconst getServerSnapshot = React.useCallback(() => initialValue as T | undefined, [initialValue]);\n\n\tconst subscribeKey = React.useCallback((onStoreChange: () => void) => {\n\t\tif (!key) return () => { };\n\t\treturn subscribe(key, onStoreChange);\n\t}, [subscribe, key]);\n\n\tconst value = React.useSyncExternalStore(\n\t\tsubscribeKey,\n\t\tgetSnapshot as unknown as () => T | undefined,\n\t\tgetServerSnapshot as unknown as () => T | undefined\n\t);\n\n\tconst set = React.useCallback((v: T | ((prev: T | undefined) => T)) => {\n\t\tif (!key) return;\n\t\tconst next = typeof v === \"function\"\n\t\t\t? (v as (prev: T | undefined) => T)((get(key) as T | undefined) ?? (initialValue as T | undefined))\n\t\t\t: v;\n\t\tsetState(key, next as T);\n\t}, [setState, key, get, initialValue]);\n\n\treturn [value, set];\n}\n\nexport function useUIColor(key: string | undefined, initialColor?: { r: number; g: number; b: number }) {\n\treturn useUIValue<{ r: number; g: number; b: number }>(key, initialColor);\n}\n\nexport function useUIString(key: string | undefined, initialValue?: string) {\n\treturn useUIValue<string>(key, initialValue);\n}",
      "type": "registry:ui",
      "target": "components/obsidian/UIStateProvider.tsx"
    },
    {
      "path": "src/components/obsidian/Window.tsx",
      "content": "import Image from \"next/image\";\nimport { MoveDiagonal2, Move, Search } from \"lucide-react\";\nimport { Tabs, TabsList, TabsTrigger, TabsContent } from \"@/components/ui/tabs\";\nimport React, { ReactNode } from \"react\";\n\nimport { cn } from \"@/lib/utils\";\nimport { TabParser } from \"./DynamicTab\";\nimport { UIData } from \"./element.types\";\nimport { IBMMono } from \"./fonts\";\n\nimport * as LucideIcons from \"lucide-react\";\ntype LucideIcon = React.ComponentType<React.ComponentProps<\"svg\">>;\nconst normalizeIconName = (name?: string) => {\n  if (!name) return name;\n  return name.endsWith(\"Icon\") ? name.slice(0, -4) : name;\n};\nconst getIcon = (name?: string) => {\n  const key = normalizeIconName(name);\n  return (\n    (key && (LucideIcons as unknown as Record<string, LucideIcon>)[key]) || null\n  );\n};\n\ninterface ObsidianWindowProps {\n  title: ReactNode | string;\n  icon?: ReactNode | string;\n  footer: ReactNode | string;\n  uiData?: UIData;\n  width?: number | string;\n  height?: number | string;\n}\n\nexport function ObsidianWindow({\n  title,\n  icon,\n  footer,\n  uiData,\n  width,\n  height,\n}: ObsidianWindowProps) {\n  const sortedTabs = React.useMemo(\n    () =>\n      uiData\n        ? Object.entries(uiData.tabs).sort(([, a], [, b]) => a.order - b.order)\n        : [],\n    [uiData]\n  );\n  const defaultTab = sortedTabs[0]?.[0] || \"Home\";\n\n  if (!uiData) return <p>Loading Features...</p>;\n  const w = typeof width === \"number\" ? `${width}px` : width ?? \"720px\";\n  const h = typeof height === \"number\" ? `${height}px` : height ?? \"600px\";\n  return (\n    <div\n      className={cn(\n        \"rounded-[3px] bg-[rgb(15,15,15)] border-[rgb(40,40,40)] border relative font-normal stroke-white text-white\",\n        IBMMono.className\n      )}\n      style={{ width: w, height: h }}\n    >\n      <div className=\"w-full h-[48px] flex flex-row px-0 bg-[rbga(13,13,13,1)]\">\n        {/* Title */}\n        <div className=\"flex flex-row items-center justify-center w-[30%] h-full gap-[3px] border-b-[rgb(40,40,40)] border-b\">\n          {typeof icon === \"string\" ? (\n            <Image src={icon} width={30} height={30} alt=\"logo\" />\n          ) : (\n            icon ?? null\n          )}\n          <span className=\"text-white text-sm ml-1\">{title}</span>\n        </div>\n\n        <div className=\"w-[70%] h-full flex flex-row items-center gap-[3px] border-l-[rgb(40,40,40)] border-l border-b-[rgb(40,40,40)] border-b\">\n          <div className=\"absolute mt-0 left-[214px] w-[505px] h-[49px] flex items-center\">\n            {/* Searchbox */}\n            <div className=\"flex items-center w-[449px] h-[34px] ml-[8px] mt-[1px] bg-[#191919] border border-[#272727] rounded px-2\">\n              <Search className=\"text-[#5f5f5f] mr-2\" />\n              <input\n                type=\"text\"\n                placeholder=\"Search\"\n                aria-label=\"Search\"\n                className=\"w-full mt-[4px] text-center text-[13.5px] text-[#fff] bg-transparent placeholder-[#5f5f5f] outline-none\"\n              />\n            </div>\n\n            {/* Move Icon */}\n            <Move className=\"text-[rgb(40,40,40)] ml-auto mr-auto\" />\n          </div>\n        </div>\n      </div>\n\n      {/* Tabs */}\n      <Tabs\n        defaultValue={defaultTab}\n        className=\"h-[calc(100%-69px)] w-full flex flex-row bg-[#111111] gap-0\"\n      >\n        <TabsList className=\"h-full border-r-[rgb(40,40,40)] border-r min-w-[calc(30%+1.2px)] flex flex-col justify-start bg-[rgba(15,15,15,1)] rounded-none p-0\">\n          {sortedTabs.map(([tabName, tab], index) => {\n            const IconTab = getIcon(tab.icon);\n            return (\n              <TabsTrigger\n                value={tabName}\n                key={index}\n                className=\"flex flex-row items-center justify-start w-full max-h-[40px] min-h-[40px] border-b-[rgb(40,40,40)] border-b rounded-none py-[11px] px-[12px] data-[state=active]:bg-[rgb(25,25,25)] text-white text-opacity-75 data-[state=active]:text-white\"\n              >\n                {IconTab && (\n                  <IconTab className=\"text-[rgb(125,85,255)] h-full mr-2\" />\n                )}\n                <span className=\"text-[13px]\">{tabName}</span>\n              </TabsTrigger>\n            );\n          })}\n        </TabsList>\n\n        {sortedTabs.map(([tabName, tab], index) => (\n          <TabsContent\n            value={tabName}\n            key={index}\n            className=\"flex flex-col w-full max-w-[calc(100%-30%+1.2px)] bg-[#111111] p-0 mt-0 overflow-hidden\"\n          >\n            <TabParser tabData={tab} />\n          </TabsContent>\n        ))}\n      </Tabs>\n\n      {/* Footer */}\n      <div className=\"h-[20px] w-full bg-[rgb(15,15,15)] border-t-[rgb(40,40,40)] border-t absolute bottom-0 flex flex-row items-center justify-center\">\n        <p className=\"text-[12px] text-white opacity-50\">{footer}</p>\n\n        <MoveDiagonal2 className=\"text-white opacity-50 w-[16px] h-[16px] absolute right-0 mr-[2px] pointer-events-none\" />\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/Window.tsx"
    },
    {
      "path": "src/components/obsidian/element.types.ts",
      "content": "// Data Structures //\nexport interface Color3 {\n  r: number;\n  g: number;\n  b: number;\n}\n\nexport interface Vector2 {\n  x: number;\n  y: number;\n}\n\n// Addon Types //\nexport interface KeyPickerAddon {\n  type: \"KeyPicker\";\n  mode: \"Toggle\" | \"Hold\" | \"Always\";\n  value: string;\n  text: string;\n}\n\nexport interface ColorPickerAddon {\n  type: \"ColorPicker\";\n  value: Color3;\n  title: string;\n}\n\nexport type Addons = KeyPickerAddon | ColorPickerAddon;\n\n// Element Types //\ninterface BaseElement {\n  index: number;\n  visible: boolean;\n  type: string;\n  text: string;\n  disabled: boolean;\n}\n\nexport interface ToggleElement extends BaseElement {\n  type: \"Toggle\";\n  value: boolean;\n  properties: {\n    risky: boolean;\n    addons?: Addons[] | undefined;\n  };\n}\n\nexport interface LabelElement extends BaseElement {\n  type: \"Label\";\n  properties: {\n    doesWrap: boolean;\n    addons?: Addons[] | undefined;\n  };\n}\n\nexport interface ButtonElement extends BaseElement {\n  type: \"Button\";\n  subButton?: {\n    text: string;\n  };\n}\n\nexport interface DropdownElement extends BaseElement {\n  type: \"Dropdown\";\n  value: string | { [key: string]: boolean };\n  properties: {\n    values: string[];\n    disabledValues: string[] | undefined;\n    multi: boolean | undefined;\n  };\n}\n\nexport interface SliderElement extends BaseElement {\n  type: \"Slider\";\n  value: number;\n  properties: {\n    min: number;\n    max: number;\n    compact: boolean | undefined;\n    rounding: number | undefined;\n    prefix: string;\n    suffix: string;\n  };\n}\n\nexport interface InputElement extends BaseElement {\n  type: \"Input\";\n  value: string;\n  properties: {\n    placeholder: string;\n    finished: boolean;\n    emptyReset: string;\n    numeric: boolean;\n    clearTextOnFocus: boolean;\n    allowEmpty: boolean;\n  };\n}\n\nexport interface DividerElement extends BaseElement {\n  type: \"Divider\";\n  properties: object;\n}\n\nexport interface ImageElement extends BaseElement {\n  type: \"Image\";\n  visible: boolean;\n  properties: {\n    image: string;\n    color: Color3;\n    rectOffset: Vector2;\n    rectSize: Vector2;\n    height: number;\n    scaleType: string;\n    transparency: number;\n  };\n}\n\nexport type UIElement =\n  | ToggleElement\n  | LabelElement\n  | ButtonElement\n  | DropdownElement\n  | SliderElement\n  | InputElement\n  | DividerElement\n  | ImageElement;\n\n// JSON File Types //\nexport interface GroupboxData {\n  name: string;\n  order: number;\n  side: \"Left\" | \"Right\" | \"Unknown\";\n  elements: UIElement[];\n}\n\nexport interface TabboxTab {\n  type: \"Tab\";\n  name: string;\n  order: number;\n  elements: UIElement[];\n}\n\nexport interface TabboxData {\n  type: \"Tabbox\";\n  name: string;\n  side: \"Left\" | \"Right\" | \"Unknown\";\n  tabs: {\n    [key: string]: TabboxTab;\n  };\n}\n\nexport interface TabData {\n  name: string;\n  type: string;\n  icon: string;\n  order: number;\n  tabboxes: {\n    Left: TabboxData[];\n    Right: TabboxData[];\n    Unknown: TabboxData[];\n  };\n  groupboxes: {\n    Left: { [key: string]: GroupboxData };\n    Right: { [key: string]: GroupboxData };\n    Unknown: { [key: string]: GroupboxData };\n  };\n  warningBox: {\n    Visible: boolean;\n    Title: string;\n    IsNormal: boolean;\n    Text: string;\n    LockSize: boolean;\n  };\n}\n\nexport interface UIData {\n  tabs: {\n    [key: string]: TabData;\n  };\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/element.types.ts"
    },
    {
      "path": "src/components/obsidian/fonts.ts",
      "content": "import { IBM_Plex_Mono } from \"next/font/google\";\nexport const IBMMono = IBM_Plex_Mono({\n\tweight: [\"400\"],\n\tsubsets: [\"latin\"],\n\tvariable: \"--font\",\n});",
      "type": "registry:ui",
      "target": "components/obsidian/fonts.ts"
    },
    {
      "path": "src/components/obsidian/obsidian.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport type { ReactNode } from \"react\";\n\nimport type {\n  UIData,\n  TabData,\n  GroupboxData,\n  UIElement,\n  Color3,\n  Vector2,\n  TabboxData,\n} from \"./element.types\";\nimport { UIStateProvider } from \"./UIStateProvider\";\nimport { ObsidianWindow } from \"./Window\";\n\n// Root wrapper props\ntype ObsidianWrapperProps = {\n  title: ReactNode | string;\n  icon?: ReactNode | string;\n  footer: ReactNode | string;\n  uiData?: unknown;\n  children?: ReactNode;\n  width?: number | string;\n  height?: number | string;\n};\n\n// DSL component prop types\nexport type ObsidianTabProps = {\n  name: string;\n  order?: number;\n  icon?: string;\n  children?: ReactNode;\n};\n\nexport type ObsidianSideProps = { children?: ReactNode };\n\nexport type ObsidianGroupboxProps = {\n  name: string;\n  order?: number;\n  children?: ReactNode;\n};\n\nexport type OToggleProps = {\n  text: string;\n  defaultChecked?: boolean;\n  risky?: boolean;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type OLabelProps = {\n  text: string;\n  doesWrap?: boolean;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type OButtonProps = {\n  text: string;\n  visible?: boolean;\n  disabled?: boolean;\n  subButtonText?: string;\n};\n\nexport type ODropdownProps = {\n  text: string;\n  value?: string | { [key: string]: boolean };\n  options: string[];\n  disabledValues?: string[];\n  multi?: boolean;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type OSliderProps = {\n  text: string;\n  value?: number;\n  min?: number;\n  max?: number;\n  compact?: boolean;\n  rounding?: number;\n  prefix?: string;\n  suffix?: string;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type OInputProps = {\n  text: string;\n  value?: string;\n  placeholder?: string;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type ODividerProps = {\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type OImageProps = {\n  text?: string;\n  image: string;\n  color?: Color3;\n  rectOffset?: Vector2;\n  rectSize?: Vector2;\n  height?: number;\n  scaleType?: string;\n  transparency?: number;\n  visible?: boolean;\n  disabled?: boolean;\n};\n\nexport type TabWarningProps = {\n  visible?: boolean;\n  title?: string;\n  text?: string;\n  isNormal?: boolean;\n  lockSize?: boolean;\n};\n\n// DSL marker components (return null; used only for structure parsing)\nconst TAGS = {\n  Tab: \"obsidian-tab\",\n  Left: \"obsidian-left\",\n  Right: \"obsidian-right\",\n  Groupbox: \"obsidian-groupbox\",\n  Toggle: \"obsidian-toggle\",\n  Label: \"obsidian-label\",\n  Button: \"obsidian-button\",\n  Dropdown: \"obsidian-dropdown\",\n  Slider: \"obsidian-slider\",\n  Input: \"obsidian-input\",\n  Divider: \"obsidian-divider\",\n  Image: \"obsidian-image\",\n  TabWarning: \"obsidian-tabwarning\",\n} as const;\n\n// Strongly-typed, no-op marker components used for structural parsing\nconst makeMarker = <P extends object>(display: string) => {\n  const Marker: React.FC<P> = () => null;\n  Marker.displayName = display;\n  return Marker;\n};\n\nexport const ObsidianTab = makeMarker<ObsidianTabProps>(\"ObsidianTab\");\nexport const ObsidianLeft = makeMarker<ObsidianSideProps>(\"ObsidianLeft\");\nexport const ObsidianRight = makeMarker<ObsidianSideProps>(\"ObsidianRight\");\nexport const ObsidianGroupbox = makeMarker<ObsidianGroupboxProps>(\n  \"ObsidianGroupbox\"\n);\n\nexport const OToggle = makeMarker<OToggleProps>(\"OToggle\");\nexport const OLabel = makeMarker<OLabelProps>(\"OLabel\");\nexport const OButton = makeMarker<OButtonProps>(\"OButton\");\nexport const ODropdown = makeMarker<ODropdownProps>(\"ODropdown\");\nexport const OSlider = makeMarker<OSliderProps>(\"OSlider\");\nexport const OInput = makeMarker<OInputProps>(\"OInput\");\nexport const ODivider = makeMarker<ODividerProps>(\"ODivider\");\nexport const OImage = makeMarker<OImageProps>(\"OImage\");\nexport const TabWarning = makeMarker<TabWarningProps>(\"TabWarning\");\n\n// Long-form aliases for convenience in pages\nexport { OLabel as ObsidianLabel };\nexport { OToggle as ObsidianToggle };\nexport { OButton as ObsidianButton };\nexport { ODropdown as ObsidianDropdown };\nexport { OSlider as ObsidianSlider };\nexport { OInput as ObsidianInput };\nexport { ODivider as ObsidianDivider };\nexport { OImage as ObsidianImage };\nexport { TabWarning as ObsidianTabWarning };\n\n// Parsing helpers\nconst MARK = \"__obsidianType\";\ntype ElementLike = { type?: unknown };\nfunction isTag(node: ReactNode, tag: string): node is React.ReactElement {\n  return !!(node && typeof node === \"object\" && (node as ElementLike).type === tag);\n}\nfunction getExportNameFromClientRef(ref: unknown): string | undefined {\n  // Next.js client references often have an $$id like \"path/to/file.tsx#ExportName\"\n  const maybe = ref as { $$id?: unknown } | undefined;\n  const id = maybe && typeof maybe.$$id === \"string\" ? maybe.$$id : undefined;\n  if (!id) return undefined;\n  const hash = id.lastIndexOf(\"#\");\n  return hash >= 0 ? id.slice(hash + 1) : undefined;\n}\n\ntype NameLike = {\n  displayName?: string;\n  name?: string;\n  _name?: string;\n  render?: { displayName?: string; name?: string };\n};\nfunction getTypeName(t: unknown): string | undefined {\n  const n = t as NameLike | undefined;\n  return (\n    n?.displayName ||\n    n?.name ||\n    n?._name ||\n    n?.render?.displayName ||\n    n?.render?.name ||\n    getExportNameFromClientRef(t)\n  );\n}\n\nfunction isElementOfType<T>(\n  node: ReactNode,\n  cmp: React.ComponentType<T>\n): node is React.ReactElement<T> {\n  if (!React.isValidElement(node)) return false;\n  const t = node.type as unknown;\n  if (t === cmp) return true;\n\n  const tName = getTypeName(t);\n  const cName = getTypeName(cmp);\n\n  if (!tName || !cName) return false;\n\n  // Allow matching \"Obsidian.Tab\" to \"ObsidianTab\" and vice versa.\n  const normalize = (s: string) => s.replace(/\\./g, \"\");\n  return normalize(tName) === normalize(cName);\n}\n\nfunction isMarker(\n  node: ReactNode,\n  type: string\n): node is React.ReactElement {\n  if (!node || typeof node !== \"object\") return false;\n  const el = node as { props?: Record<string, unknown> };\n  return !!(el.props && el.props[MARK] === type);\n}\n\nfunction parseElements(\n  children: ReactNode,\n  startIndex = 0\n): { elements: UIElement[]; lastIndex: number } {\n  const elements: UIElement[] = [];\n  let idx = startIndex;\n\n  React.Children.forEach(children, (child) => {\n    if (\n      isElementOfType(child, OToggle) ||\n      isMarker(child, \"Toggle\") ||\n      isTag(child, TAGS.Toggle)\n    ) {\n      const p = child.props as OToggleProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Toggle\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        value: p.defaultChecked ?? false,\n        properties: { risky: p.risky ?? false },\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, OLabel) ||\n      isMarker(child, \"Label\") ||\n      isTag(child, TAGS.Label)\n    ) {\n      const p = child.props as OLabelProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Label\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        properties: { doesWrap: p.doesWrap ?? false },\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, OButton) ||\n      isMarker(child, \"Button\") ||\n      isTag(child, TAGS.Button)\n    ) {\n      const p = child.props as OButtonProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Button\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        subButton: p.subButtonText ? { text: p.subButtonText } : undefined,\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, ODropdown) ||\n      isMarker(child, \"Dropdown\") ||\n      isTag(child, TAGS.Dropdown)\n    ) {\n      const p = child.props as ODropdownProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Dropdown\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        value: p.value ?? (p.multi ? {} : p.options?.[0] ?? \"\"),\n        properties: {\n          values: p.options ?? [],\n          disabledValues: p.disabledValues ?? [],\n          multi: p.multi ?? false,\n        },\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, OSlider) ||\n      isMarker(child, \"Slider\") ||\n      isTag(child, TAGS.Slider)\n    ) {\n      const p = child.props as OSliderProps;\n      const min = p.min ?? 0;\n      const max = p.max ?? 100;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Slider\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        value: p.value ?? min,\n        properties: {\n          min,\n          max,\n          compact: p.compact,\n          rounding: p.rounding,\n          prefix: p.prefix ?? \"\",\n          suffix: p.suffix ?? \"\",\n        },\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, OInput) ||\n      isMarker(child, \"Input\") ||\n      isTag(child, TAGS.Input)\n    ) {\n      const p = child.props as OInputProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Input\",\n        text: p.text,\n        disabled: p.disabled ?? false,\n        value: p.value ?? \"\",\n        properties: {\n          placeholder: p.placeholder ?? \"\",\n          finished: false,\n          emptyReset: \"\",\n          numeric: false,\n          clearTextOnFocus: false,\n          allowEmpty: true,\n        },\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, ODivider) ||\n      isMarker(child, \"Divider\") ||\n      isTag(child, TAGS.Divider)\n    ) {\n      const p = child.props as ODividerProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Divider\",\n        text: \"\",\n        disabled: p.disabled ?? false,\n        properties: {},\n      } as unknown as UIElement);\n      return;\n    }\n    if (\n      isElementOfType(child, OImage) ||\n      isMarker(child, \"Image\") ||\n      isTag(child, TAGS.Image)\n    ) {\n      const p = child.props as OImageProps;\n      elements.push({\n        index: idx++,\n        visible: p.visible ?? true,\n        type: \"Image\",\n        text: p.text ?? \"\",\n        disabled: p.disabled ?? false,\n        properties: {\n          image: p.image,\n          color: p.color ?? { r: 255, g: 255, b: 255 },\n          rectOffset: p.rectOffset ?? { x: 0, y: 0 },\n          rectSize: p.rectSize ?? { x: 0, y: 0 },\n          height: p.height ?? 30,\n          scaleType: p.scaleType ?? \"Fit\",\n          transparency: p.transparency ?? 1,\n        },\n      } as unknown as UIElement);\n      return;\n    }\n  });\n\n  return { elements, lastIndex: idx };\n}\n\nfunction parseGroupboxes(children: ReactNode): {\n  byName: { [key: string]: GroupboxData };\n} {\n  const out: { [key: string]: GroupboxData } = {};\n  let globalIndex = 0;\n\n  React.Children.forEach(children, (child) => {\n    if (\n      !isElementOfType(child, ObsidianGroupbox) &&\n      !isMarker(child, \"Groupbox\") &&\n      !isTag(child, TAGS.Groupbox)\n    )\n      return;\n    const p = child.props as ObsidianGroupboxProps;\n\n    const { elements } = parseElements(p.children, 0);\n    const gb: GroupboxData = {\n      name: p.name,\n      order: p.order ?? 0,\n      side: \"Unknown\",\n      elements: elements.map((el) => ({\n        ...el,\n        index: globalIndex++,\n      })) as unknown as UIElement[],\n    };\n    out[p.name] = gb;\n  });\n\n  return { byName: out };\n}\n\nfunction parseTabs(children: ReactNode): UIData {\n  const tabs: { [key: string]: TabData } = {};\n\n  React.Children.forEach(children, (child) => {\n    if (\n      !isElementOfType(child, ObsidianTab) &&\n      !isMarker(child, \"Tab\") &&\n      !isTag(child, TAGS.Tab)\n    )\n      return;\n    const p = child.props as ObsidianTabProps;\n\n    const leftNode = React.Children.toArray(p.children).find(\n      (c) =>\n        isElementOfType(c, ObsidianLeft) ||\n        isMarker(c, \"Left\") ||\n        isTag(c, TAGS.Left)\n    ) as React.ReactElement | undefined;\n    const rightNode = React.Children.toArray(p.children).find(\n      (c) =>\n        isElementOfType(c, ObsidianRight) ||\n        isMarker(c, \"Right\") ||\n        isTag(c, TAGS.Right)\n    ) as React.ReactElement | undefined;\n    const warningNode = React.Children.toArray(p.children).find(\n      (c) =>\n        isElementOfType(c, TabWarning) ||\n        isMarker(c, \"TabWarning\") ||\n        isTag(c, TAGS.TabWarning)\n    ) as React.ReactElement | undefined;\n\n    const left = leftNode\n      ? parseGroupboxes(\n          (leftNode.props as { children?: React.ReactNode }).children\n        )\n      : { byName: {} };\n    const right = rightNode\n      ? parseGroupboxes(\n          (rightNode.props as { children?: React.ReactNode }).children\n        )\n      : { byName: {} };\n\n    const tabData: TabData = {\n      name: p.name,\n      type: \"Tab\",\n      icon: p.icon ?? \"\",\n      order: p.order ?? 0,\n      tabboxes: { Left: [], Right: [], Unknown: [] },\n      groupboxes: {\n        Left: left.byName,\n        Right: right.byName,\n        Unknown: {},\n      },\n      warningBox: {\n        Visible: (warningNode?.props as TabWarningProps)?.visible ?? false,\n        Title: (warningNode?.props as TabWarningProps)?.title ?? \"\",\n        IsNormal: (warningNode?.props as TabWarningProps)?.isNormal ?? true,\n        Text: (warningNode?.props as TabWarningProps)?.text ?? \"\",\n        LockSize: (warningNode?.props as TabWarningProps)?.lockSize ?? false,\n      },\n    };\n\n    tabs[p.name] = tabData;\n  });\n\n  return { tabs } as UIData;\n}\n\nfunction buildUIData(children?: ReactNode): UIData | undefined {\n  if (!children) return undefined;\n  return parseTabs(children);\n}\n\n// Accepts a variety of shapes and normalizes into UIData\nfunction normalizeUIData(data: unknown): UIData | undefined {\n  if (!data || typeof data !== \"object\") return undefined;\n  const anyData = data as { tabs?: unknown };\n  const tabsSrc =\n    anyData.tabs && typeof anyData.tabs === \"object\"\n      ? (anyData.tabs as Record<string, unknown>)\n      : undefined;\n  if (!tabsSrc) return undefined;\n\n  const outTabs: Record<string, TabData> = {};\n  for (const [name, raw] of Object.entries(tabsSrc as Record<string, unknown>)) {\n    if (!raw || typeof raw !== \"object\") continue;\n\n    type RawTab = {\n      name?: string;\n      type?: string;\n      icon?: string;\n      order?: unknown;\n      tabboxes?: {\n        Left?: unknown;\n        Right?: unknown;\n        Unknown?: unknown;\n      };\n      groupboxes?: {\n        Left?: unknown;\n        Right?: unknown;\n        Unknown?: unknown;\n      };\n      warningBox?: {\n        Visible?: unknown;\n        Title?: unknown;\n        IsNormal?: unknown;\n        Text?: unknown;\n        LockSize?: unknown;\n      };\n    };\n\n    const normalizeGroupSide = (side: unknown): { [key: string]: GroupboxData } => {\n      if (!side) return {};\n      if (Array.isArray(side)) {\n        const acc: { [key: string]: GroupboxData } = {};\n        for (const gb of side as unknown[]) {\n          const maybeGb = gb as Partial<GroupboxData> | undefined;\n          if (maybeGb && maybeGb.name) acc[String(maybeGb.name)] = maybeGb as GroupboxData;\n        }\n        return acc;\n      }\n      if (typeof side === \"object\")\n        return side as { [key: string]: GroupboxData };\n      return {};\n    };\n\n    const normalizeTabSide = (side: unknown): TabboxData[] => {\n      if (!side) return [];\n      if (Array.isArray(side)) return side as TabboxData[];\n      if (typeof side === \"object\")\n        return Object.values(side as Record<string, TabboxData>);\n      return [];\n    };\n\n    const rawTab = raw as RawTab;\n    const tabboxes = rawTab.tabboxes ?? { Left: [], Right: [], Unknown: [] };\n    const groupboxes = rawTab.groupboxes ?? { Left: {}, Right: {}, Unknown: {} };\n\n    outTabs[name] = {\n      name: (rawTab.name ?? name) as string,\n      type: (rawTab.type ?? \"Tab\") as string,\n      icon: (rawTab.icon ?? \"\") as string,\n      order: Number(rawTab.order ?? 0),\n      tabboxes: {\n        Left: normalizeTabSide(tabboxes.Left),\n        Right: normalizeTabSide(tabboxes.Right),\n        Unknown: normalizeTabSide(tabboxes.Unknown),\n      },\n      groupboxes: {\n        Left: normalizeGroupSide(groupboxes.Left),\n        Right: normalizeGroupSide(groupboxes.Right),\n        Unknown: normalizeGroupSide(groupboxes.Unknown),\n      },\n      warningBox: {\n        Visible: Boolean(rawTab.warningBox?.Visible ?? false),\n        Title: String(rawTab.warningBox?.Title ?? \"\"),\n        IsNormal: Boolean(rawTab.warningBox?.IsNormal ?? true),\n        Text: String(rawTab.warningBox?.Text ?? \"\"),\n        LockSize: Boolean(rawTab.warningBox?.LockSize ?? false),\n      },\n    } as TabData;\n  }\n\n  return { tabs: outTabs } as UIData;\n}\n\nexport function Obsidian({\n  title,\n  icon,\n  footer,\n  uiData,\n  children,\n  width,\n  height,\n}: ObsidianWrapperProps) {\n  const data = React.useMemo(() => {\n    const fromChildren = buildUIData(children);\n    const fromProp = normalizeUIData(uiData);\n    return fromProp ?? fromChildren;\n  }, [uiData, children]);\n\n  return (\n    <UIStateProvider>\n      <ObsidianWindow\n        title={title}\n        icon={icon}\n        footer={footer}\n        uiData={data}\n        width={width}\n        height={height}\n      />\n    </UIStateProvider>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/obsidian.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Button.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport * as React from \"react\";\nimport type { ReactNode } from \"react\";\n\nexport const ButtonBase = React.forwardRef<\n\tHTMLButtonElement,\n\t{\n\t\ttext: string | ReactNode;\n\t\tcontainerClassName?: string;\n\t\tclassName?: string;\n\t\tchildren?: ReactNode;\n\t\treplacedText?: boolean;\n\t} & React.ButtonHTMLAttributes<HTMLButtonElement>\n>(({\n\ttext,\n\tcontainerClassName,\n\tclassName,\n\tchildren,\n\treplacedText = false,\n\t...props\n}, ref) => {\n\treturn (\n\t\t<button\n\t\t\tref={ref}\n\t\t\ttype=\"button\"\n\t\t\tclassName={cn(\n\t\t\t\t\"w-full h-[26px] justify-center rounded-[1px] bg-[rgb(25,25,25)] hover:bg-[rgb(35,35,35)] border-[rgb(40,40,40)] border cursor-pointer inline-flex items-center\",\n\t\t\t\tcontainerClassName\n\t\t\t)}\n\t\t\t{...props}\n\t\t>\n\t\t\t{!replacedText ? (\n\t\t\t\t<span className={cn(\"text-center text-white text-[12px] opacity-50 truncate\", className)}>\n\t\t\t\t\t{text}\n\t\t\t\t</span>\n\t\t\t) : (text)}\n\t\t\t{children}\n\t\t</button>\n\t);\n});\n\nButtonBase.displayName = \"ButtonBase\";\n\nexport default function Button({\n\ttext,\n\tsubButton,\n}: {\n\ttext: string;\n\tsubButton?: { text: string; };\n}) {\n\tif (subButton != undefined) {\n\t\treturn (\n\t\t\t<div className=\"flex flex-row gap-2\">\n\t\t\t\t<ButtonBase text={text} containerClassName=\"min-w-0 flex-1 flex-shrink\" />\n\t\t\t\t<ButtonBase text={subButton.text} containerClassName=\"min-w-0 flex-1 flex-shrink\" />\n\t\t\t</div>\n\t\t);\n\t}\n\n\treturn <ButtonBase text={text} />;\n}",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Button.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Divider.tsx",
      "content": "export default function Divider() {\n  return (\n    <hr className=\"w-full h-[4px] border-[rgb(40,40,40)] border mt-0 mb-0\" />\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Divider.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Dropdown.tsx",
      "content": "\"use client\";\n\nimport { ChevronUp } from \"lucide-react\";\nimport { ButtonBase } from \"./Button\";\nimport Label from \"./Label\";\nimport React from \"react\";\nimport { cn } from \"@/lib/utils\";\nimport { IBMMono } from \"../fonts\";\nimport { useUIValue } from \"../UIStateProvider\";\n\nfunction useClickOutside(\n  ref: React.RefObject<HTMLElement>,\n  onOutside: () => void\n) {\n  React.useEffect(() => {\n    const handler = (e: MouseEvent) => {\n      if (!ref.current) return;\n      if (!ref.current.contains(e.target as Node)) onOutside();\n    };\n    document.addEventListener(\"mousedown\", handler, {\n      passive: true,\n    } as AddEventListenerOptions);\n    return () =>\n      document.removeEventListener(\"mousedown\", handler as EventListener);\n  }, [ref, onOutside]);\n}\n\nconst NoAnimationClassName =\n  \"data-[state=open]:animate-none data-[state=closed]:animate-none data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0\";\n\nexport default function Dropdown({\n  text,\n  value,\n  options,\n  multi,\n  disabledValues = [],\n  stateKey,\n}: {\n  text: string;\n  value: string | string[] | { [key: string]: boolean };\n  options: string[];\n  multi: boolean | undefined;\n  disabledValues?: string[];\n  stateKey?: string;\n}) {\n  const [isOpen, setIsOpen] = React.useState(false);\n  const [externalSelected, setExternalSelected] = useUIValue<\n    string | { [key: string]: boolean }\n  >(stateKey, undefined);\n\n  const initial = React.useMemo(() => externalSelected, [externalSelected]);\n  const normalizeInitial = React.useCallback(():\n    | string\n    | { [key: string]: boolean } => {\n    if (multi) {\n      if (initial !== undefined) {\n        if (\n          initial !== null &&\n          typeof initial === \"object\" &&\n          !Array.isArray(initial)\n        )\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          return initial as any;\n\n        if (Array.isArray(initial))\n          return (initial as string[]).reduce(\n            (acc, k) => ({ ...acc, [k]: true }),\n            {} as Record<string, boolean>\n          );\n\n        if (typeof initial === \"string\") return { [initial]: true };\n      }\n\n      if (Array.isArray(value))\n        return (value as string[]).reduce(\n          (acc, k) => ({ ...acc, [k]: true }),\n          {} as Record<string, boolean>\n        );\n\n      if (typeof value === \"object\" && value !== null && !Array.isArray(value))\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return value as any;\n\n      if (typeof value === \"string\") return { [value]: true };\n\n      return {};\n    }\n    if (initial !== undefined) {\n      if (typeof initial === \"string\") return initial as string;\n\n      if (Array.isArray(initial)) return (initial as string[])[0] ?? \"\";\n\n      if (typeof initial === \"object\" && initial !== null) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const k = Object.keys(initial as any).find(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (kk) => (initial as any)[kk]\n        );\n        return k ?? \"\";\n      }\n    }\n\n    if (typeof value === \"string\") return value as string;\n\n    if (Array.isArray(value)) return (value as string[])[0] ?? \"\";\n\n    if (typeof value === \"object\" && value !== null) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const k = Object.keys(value as any).find((kk) => (value as any)[kk]);\n      return k ?? \"\";\n    }\n\n    return \"\";\n  }, [initial, multi, value]);\n\n  const [local, setLocal] = React.useState<string | { [key: string]: boolean }>(\n    normalizeInitial\n  );\n\n  React.useEffect(() => {\n    if (stateKey && externalSelected !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      setLocal(externalSelected as any);\n    }\n  }, [externalSelected, stateKey]);\n\n  const selected = local;\n  const updateSelected = React.useCallback(\n    (newVal: string | { [key: string]: boolean }) => {\n      setLocal(newVal);\n      if (stateKey) {\n        setExternalSelected(newVal);\n      }\n    },\n    [setExternalSelected, stateKey]\n  );\n\n  const ITEM_HEIGHT = 24;\n  const MAX_PANEL_HEIGHT = 168;\n  const OVERSCAN = 6;\n\n  const [scrollTop, setScrollTop] = React.useState(0);\n  const { visibleOptions, startIndex, topSpacer, bottomSpacer } =\n    React.useMemo(() => {\n      const visibleCount = Math.ceil(MAX_PANEL_HEIGHT / ITEM_HEIGHT) + OVERSCAN;\n      const startIdx = Math.max(\n        0,\n        Math.floor(scrollTop / ITEM_HEIGHT) - Math.floor(OVERSCAN / 2)\n      );\n      const endIdx = Math.min(options.length, startIdx + visibleCount);\n      return {\n        visibleOptions: options.slice(startIdx, endIdx),\n        startIndex: startIdx,\n        topSpacer: startIdx * ITEM_HEIGHT,\n        bottomSpacer: (options.length - endIdx) * ITEM_HEIGHT,\n      };\n    }, [scrollTop, options]);\n\n  // close on outside click\n  const rootRef = React.useRef<HTMLDivElement | null>(null);\n  useClickOutside(rootRef as unknown as React.RefObject<HTMLElement>, () =>\n    setIsOpen(false)\n  );\n\n  const displayText = React.useMemo(() => {\n    if (multi) {\n      if (\n        selected &&\n        typeof selected === \"object\" &&\n        !Array.isArray(selected)\n      ) {\n        const keys = Object.keys(selected).filter(\n          (k) => (selected as Record<string, boolean>)[k]\n        );\n        return keys.length ? keys.join(\", \") : \"---\";\n      }\n      return \"---\";\n    }\n    const s =\n      typeof selected === \"string\" && selected.trim().length ? selected : \"---\";\n    return s;\n  }, [multi, selected]);\n\n  const onScroll = React.useCallback((e: React.UIEvent<HTMLDivElement>) => {\n    const t = (e.currentTarget as HTMLDivElement).scrollTop;\n    setScrollTop(t);\n  }, []);\n\n  const onSelectOption = React.useCallback(\n    (option: string) => {\n      if (disabledValues.includes(option)) return;\n      if (multi) {\n        const selMap: Record<string, boolean> =\n          typeof selected === \"object\" && !Array.isArray(selected)\n            ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              (selected as any)\n            : {};\n        const isSelected = !!selMap[option];\n        updateSelected({ ...selMap, [option]: !isSelected });\n      } else {\n        updateSelected(option);\n        setIsOpen(false);\n      }\n    },\n    [disabledValues, multi, selected, updateSelected]\n  );\n\n  const listboxId = React.useId();\n  return (\n    <div className=\"flex flex-col gap-1\">\n      <Label className=\"text-white opacity-100\">{text}</Label>\n\n      <div\n        className=\"relative\"\n        ref={rootRef as unknown as React.RefObject<HTMLDivElement>}\n      >\n        <ButtonBase\n          text={displayText}\n          className=\"absolute w-[calc(100%-35px)] text-left text-white opacity-100 m-1 text-xs\"\n          containerClassName=\"justify-start flex relative\"\n          onClick={() => setIsOpen((v) => !v)}\n          aria-haspopup=\"listbox\"\n          aria-expanded={isOpen}\n          aria-controls={listboxId}\n        >\n          <div className=\"absolute right-0 top-0 h-full opacity-50\">\n            <ChevronUp\n              className={cn(\"w-[20px] mr-1\", { \"-rotate-180\": isOpen })}\n            />\n          </div>\n        </ButtonBase>\n\n        {isOpen && (\n          <div\n            role=\"listbox\"\n            id={listboxId}\n            aria-multiselectable={!!multi}\n            className={cn(\n              NoAnimationClassName,\n              \"absolute left-0 right-0 z-50 max-h-[168px]\",\n              \"rounded-[1px] bg-[rgb(15,15,15)] border-[rgb(40,40,40)] border\",\n              \"overflow-scroll\",\n              \"no-scrollbar\",\n              \"text-white\"\n            )}\n            onScroll={onScroll}\n          >\n            {topSpacer > 0 && <div style={{ height: `${topSpacer}px` }} />}\n            {visibleOptions.map((option, i) => (\n              <div\n                key={startIndex + i}\n                className={cn(\n                  \"py-0 gap-1 px-1 flex items-center cursor-pointer\",\n                  (() => {\n                    const isSelected = multi\n                      ? typeof selected === \"object\" &&\n                        selected !== null &&\n                        !Array.isArray(selected) &&\n                        (selected as Record<string, boolean>)[option] === true\n                      : selected === option;\n                    return isSelected && \"bg-[rgb(40,40,40)]\";\n                  })(),\n                  disabledValues.includes(option) &&\n                    \"bg-[rgb(0,0,0)] opacity-40 cursor-not-allowed\",\n                  IBMMono.className\n                )}\n                role=\"option\"\n                aria-selected={\n                  multi\n                    ? !!(\n                        typeof selected === \"object\" &&\n                        selected &&\n                        !Array.isArray(selected) &&\n                        (selected as Record<string, boolean>)[option]\n                      )\n                    : selected === option\n                }\n                onClick={() => onSelectOption(option)}\n                style={{ height: `${ITEM_HEIGHT}px` }}\n              >\n                <div className=\"px-0 py-0.75 text-xs\">{option}</div>\n              </div>\n            ))}\n\n            {bottomSpacer > 0 && (\n              <div style={{ height: `${bottomSpacer}px` }} />\n            )}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Dropdown.tsx"
    },
    {
      "path": "src/components/obsidian/elements/GroupBox.tsx",
      "content": "import type { ReactNode } from \"react\";\n\nexport function Groupbox({ icon: Icon, title, children }: { icon?: React.ElementType, title: string, children: ReactNode }) {\n    return (\n        <div className=\"mt-1 ml-2 mb-3 rounded-[3px] bg-[rgb(15,15,15)] border border-[rgb(40,40,40)] relative font-normal\">\n            {/* Top Bar */}\n            <div className=\"w-full h-[38px] flex flex-row bg-[rgb(15,15,15)]\">\n                {/* Title */}\n                <div className=\"flex flex-row items-center w-full border-b border-b-[rgb(40,40,40)]\">\n                    {Icon && (<Icon className=\"text-[rgb(125,85,255)] h-full ml-2 mr-[-5px]\" />)}\n                    <span className=\"text-white text-[14px] ml-3 mt-1\">{title}</span>\n                </div>\n            </div>\n\n            {/* Content */}\n            <div className=\"flex flex-col right p-2 gap-2 min-h-0\">\n                {children}\n            </div>\n        </div>\n    )\n}",
      "type": "registry:ui",
      "target": "components/obsidian/elements/GroupBox.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Image.tsx",
      "content": "import { cn } from \"@/lib/utils\";\n\nexport default function ObsidianImage({\n\timage,\n\ttransparency,\n\tscaleType,\n\tcolor,\n\trectOffset,\n\theight,\n\trectSize,\n}: {\n\timage: string;\n\ttransparency: number;\n\tscaleType: string;\n\tcolor: { b: number; g: number; r: number };\n\trectOffset: { y: number; x: number };\n\theight: number;\n\trectSize: { y: number; x: number };\n}) {\n\treturn (\n\t\t<div\n\t\t\tclassName={\"w-full rounded-[1px] bg-[rgb(25,25,25)] border-[rgb(40,40,40)] border flex items-center justify-center\"}\n\t\t\tstyle={{ height: `${height}px` }}\n\t\t>\n\t\t\t<p className=\"text-center text-muted-foreground text-sm select-none\">\n\t\t\t\tImage Unavailable\n\t\t\t</p>\n\t\t</div>\n\t);\n}",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Image.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Input.tsx",
      "content": "import React from \"react\";\nimport { ButtonBase } from \"./Button\";\nimport Label from \"./Label\";\nimport { useUIState } from \"../UIStateProvider\";\nimport { cn } from \"@/lib/utils\";\n\nexport default function Input({\n  text,\n  value,\n  placeholder,\n  stateKey,\n  className,\n  containerClassName,\n  inputClassName,\n  onChanged,\n}: {\n  text: string;\n  value: string;\n  placeholder: string;\n  stateKey?: string;\n  className?: string;\n  containerClassName?: string;\n  inputClassName?: string;\n  onChanged?: React.ChangeEventHandler<HTMLInputElement>;\n}) {\n  const { state, setState } = useUIState();\n  const [local, setLocal] = React.useState<string>(\n    (stateKey ? (state[stateKey] as string | undefined) : undefined) ?? value\n  );\n\n  React.useEffect(() => {\n    if (!stateKey) return;\n    const v = state[stateKey];\n    if (typeof v === \"string\") setLocal(v);\n  }, [state, stateKey]);\n\n  // sync with external value when uncontrolled //\n  React.useEffect(() => {\n    if (stateKey) return;\n    setLocal(value);\n  }, [value, stateKey]);\n\n  return (\n    <div className=\"flex flex-col gap-1\">\n      <Label className=\"text-white opacity-100\">{text}</Label>\n\n      <ButtonBase\n        text={\n          <input\n            name=\"input\"\n            type=\"text\"\n            className={cn(\n              \"w-full h-full text-white opacity-100 ml-1 text-xs bg-transparent outline-none\",\n              inputClassName\n            )}\n            value={local}\n            placeholder={placeholder}\n            onChange={(e) => {\n              const next = e.target.value;\n              setLocal(next);\n              if (stateKey) setState(stateKey, next);\n              if (onChanged) onChanged(e);\n            }}\n          />\n        }\n        className={cn(\n          \"text-left text-white opacity-100 m-1 text-xs\",\n          className\n        )}\n        containerClassName={cn(\n          \"justify-start flex relative\",\n          containerClassName\n        )}\n        replacedText={true}\n      />\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Input.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Label.tsx",
      "content": "import { cn } from \"@/lib/utils\";\nimport createDOMPurify from \"dompurify\";\nimport type { ReactNode, CSSProperties } from \"react\";\n\nfunction escapeHtml(input: string) {\n  return input\n    .replace(/&/g, \"&amp;\")\n    .replace(/</g, \"&lt;\")\n    .replace(/>/g, \"&gt;\")\n    .replace(/\\\"/g, \"&quot;\")\n    .replace(/'/g, \"&#39;\");\n}\n\nfunction sanitizeColor(value: string): string | null {\n  const v = value.trim();\n  if (/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(v)) return v;\n\n  const rgbMatch =\n    /^rgb\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*\\)$/i.exec(v);\n  if (rgbMatch) {\n    const r = Number(rgbMatch[1]);\n    const g = Number(rgbMatch[2]);\n    const b = Number(rgbMatch[3]);\n    if (r <= 255 && g <= 255 && b <= 255) {\n      return `rgb(${r}, ${g}, ${b})`;\n    }\n  }\n\n  const rgbaMatch =\n    /^rgba\\(\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(0|0?\\.\\d+|1(\\.0+)?)\\s*\\)$/i.exec(\n      v\n    );\n  if (rgbaMatch) {\n    const r = Number(rgbaMatch[1]);\n    const g = Number(rgbaMatch[2]);\n    const b = Number(rgbaMatch[3]);\n    const a = Number(rgbaMatch[4]);\n\n    if (r <= 255 && g <= 255 && b <= 255 && a >= 0 && a <= 1) {\n      const alpha = String(parseFloat(a.toString()));\n      return `rgba(${r}, ${g}, ${b}, ${alpha})`;\n    }\n  }\n\n  const triplet = /^(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})$/.exec(v);\n  if (triplet) {\n    const r = Number(triplet[1]);\n    const g = Number(triplet[2]);\n    const b = Number(triplet[3]);\n    if (r <= 255 && g <= 255 && b <= 255) {\n      return `rgb(${r}, ${g}, ${b})`;\n    }\n  }\n\n  return null;\n}\n\nfunction robloxRichTextToHtml(input: string): string {\n  if (!input) return \"\";\n\n  const placeholders: string[] = [];\n  const replacements: string[] = [];\n  const tokenSeed = `__RTX_${Date.now()}_${Math.random()\n    .toString(36)\n    .slice(2)}__`;\n  const makePh = (html: string) => {\n    const token = `${tokenSeed}${placeholders.length}__`;\n    placeholders.push(token);\n    replacements.push(html);\n    return token;\n  };\n  let s = String(input);\n  s = s.replace(/<\\s*b\\s*>/gi, () => makePh(\"<b>\"));\n  s = s.replace(/<\\s*\\/\\s*b\\s*>/gi, () => makePh(\"</b>\"));\n  s = s.replace(/<\\s*i\\s*>/gi, () => makePh(\"<i>\"));\n  s = s.replace(/<\\s*\\/\\s*i\\s*>/gi, () => makePh(\"</i>\"));\n  s = s.replace(/<\\s*u\\s*>/gi, () => makePh(\"<u>\"));\n  s = s.replace(/<\\s*\\/\\s*u\\s*>/gi, () => makePh(\"</u>\"));\n  s = s.replace(/<\\s*s\\s*>/gi, () => makePh(\"<s>\"));\n  s = s.replace(/<\\s*\\/\\s*s\\s*>/gi, () => makePh(\"</s>\"));\n  s = s.replace(/<\\s*br\\s*\\/?\\s*>/gi, () => makePh(\"<br/>\"));\n\n  s = s.replace(/<\\s*font([^>]*)>/gi, (_m, attrs: string) => {\n    let color: string | null = null;\n    let size: number | null = null;\n\n    const attrRegex = /(\\w+)\\s*=\\s*(\"[^\"]*\"|'[^']*'|[^\\s\"'>]+)/g;\n    let match: RegExpExecArray | null;\n    while ((match = attrRegex.exec(attrs)) !== null) {\n      const name = match[1].toLowerCase();\n      let raw = match[2];\n      if (\n        (raw.startsWith('\"') && raw.endsWith('\"')) ||\n        (raw.startsWith(\"'\") && raw.endsWith(\"'\"))\n      ) {\n        raw = raw.slice(1, -1);\n      }\n      if (name === \"color\") {\n        const c = sanitizeColor(raw);\n        if (c) color = c;\n      } else if (name === \"size\") {\n        const n = parseInt(raw, 10);\n        if (!Number.isNaN(n)) {\n          size = Math.min(Math.max(n, 6), 72);\n        }\n      }\n    }\n\n    const styles: string[] = [];\n    if (color) styles.push(`color: ${color}`);\n    if (size !== null) styles.push(`font-size: ${size}px`);\n    const styleAttr = styles.length ? ` style=\\\"${styles.join(\"; \")}\\\"` : \"\";\n    return makePh(`<span${styleAttr}>`);\n  });\n\n  s = s.replace(/<\\s*\\/\\s*font\\s*>/gi, () => makePh(\"</span>\"));\n  s = escapeHtml(s);\n  s = s.replace(/\\r\\n|\\n|\\r/g, \"<br/>\");\n\n  placeholders.forEach((ph, i) => {\n    s = s.split(ph).join(replacements[i]);\n  });\n\n  return s;\n}\n\nexport default function Label({\n  children,\n  className,\n  style,\n}: {\n  children: ReactNode;\n  className?: string;\n  style?: CSSProperties;\n}) {\n  const finalClassName = cn(\"text-left block text-white text-sm\", className);\n\n  if (typeof children === \"string\") {\n    const htmlUnsafe = robloxRichTextToHtml(children);\n    const DOMPurify = typeof window !== \"undefined\" ? createDOMPurify(window) : undefined;\n    const html = DOMPurify?.sanitize(htmlUnsafe, {\n      ALLOWED_TAGS: [\"b\", \"i\", \"u\", \"s\", \"br\", \"span\"],\n      ALLOWED_ATTR: [\"style\"],\n    }) ?? htmlUnsafe;\n    return (\n      <span\n        className={finalClassName}\n        style={style}\n        dangerouslySetInnerHTML={{ __html: html }}\n      />\n    );\n  }\n\n  return (\n    <span className={finalClassName} style={style}>\n      {children}\n    </span>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Label.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Slider.tsx",
      "content": "\"use client\";\nimport * as React from \"react\";\n\nimport { cn } from \"@/lib/utils\";\nimport { ButtonBase } from \"./Button\";\nimport Label from \"./Label\";\nimport { useUIValue } from \"../UIStateProvider\";\n\nexport default function Slider({\n  text,\n  value,\n  defaultValue,\n  min = 0,\n  max = 100,\n  step = 1,\n  compact,\n  rounding,\n  prefix,\n  suffix,\n  className,\n  onValueChange,\n  stateKey,\n}: {\n  text: string;\n  value?: number;\n  defaultValue?: number;\n  min?: number;\n  max?: number;\n  step?: number;\n  compact?: boolean;\n  rounding?: number;\n  prefix?: string;\n  suffix?: string;\n  className?: string;\n  onValueChange?: (value: number) => void;\n  stateKey?: string;\n}) {\n  const [stateValue, setStateValue] = useUIValue<number | undefined>(\n    stateKey,\n    undefined\n  );\n  const [internalValue, setInternalValue] = React.useState(\n    stateValue ?? value ?? defaultValue ?? min\n  );\n\n  const isControlled = value !== undefined && onValueChange !== undefined;\n  const currentValue = isControlled ? (value as number) : internalValue;\n\n  React.useEffect(() => {\n    if (!isControlled && stateValue !== undefined) {\n      setInternalValue(stateValue);\n    }\n  }, [stateValue, isControlled]);\n\n  const roundValue = (num: number) => {\n    if (rounding !== undefined && rounding >= 0) {\n      const multiplier = Math.pow(10, rounding);\n      return Math.round(num * multiplier) / multiplier;\n    }\n    return num;\n  };\n\n  const trackRef = React.useRef<HTMLDivElement | null>(null);\n  const draggingRef = React.useRef(false);\n\n  const quantizeToStep = (n: number) => {\n    const range = max - min;\n    if (step <= 0 || !Number.isFinite(step) || range === 0) return n;\n\n    const roundingStep =\n      rounding !== undefined && rounding >= 0 ? Math.pow(10, -rounding) : null;\n    const effectiveStep = roundingStep ? Math.min(step, roundingStep) : step;\n    const steps = Math.round((n - min) / effectiveStep);\n    const snapped = min + steps * effectiveStep;\n\n    return Math.min(max, Math.max(min, snapped));\n  };\n\n  const setFromClientX = (clientX: number) => {\n    const el = trackRef.current;\n    if (!el) return;\n\n    const rect = el.getBoundingClientRect();\n    const pct = rect.width > 0 ? (clientX - rect.left) / rect.width : 0;\n    const clampedPct = Math.min(1, Math.max(0, pct));\n    const raw = min + clampedPct * (max - min);\n    const stepped = quantizeToStep(raw);\n    const roundedValue = roundValue(stepped);\n\n    if (!isControlled) setInternalValue(roundedValue);\n    if (stateKey) setStateValue(roundedValue);\n    if (onValueChange) onValueChange(roundedValue);\n  };\n\n  const onPointerDown = (e: React.PointerEvent<HTMLDivElement>) => {\n    e.preventDefault();\n    draggingRef.current = true;\n    try {\n      (e.currentTarget as HTMLDivElement).setPointerCapture(e.pointerId);\n    } catch {}\n    setFromClientX(e.clientX);\n\n    const move = (ev: PointerEvent) => {\n      if (!draggingRef.current) return;\n      setFromClientX(ev.clientX);\n    };\n\n    const up = () => {\n      draggingRef.current = false;\n      window.removeEventListener(\"pointermove\", move);\n      window.removeEventListener(\"pointerup\", up);\n      window.removeEventListener(\"pointercancel\", up);\n    };\n\n    window.addEventListener(\"pointermove\", move);\n    window.addEventListener(\"pointerup\", up);\n    window.addEventListener(\"pointercancel\", up);\n  };\n\n  const displayValue = roundValue(currentValue);\n  const displayMax = roundValue(max);\n  const formatValue = (num: number) =>\n    rounding !== undefined && rounding >= 0\n      ? Number(num).toFixed(rounding)\n      : String(num);\n\n  const fraction = max > min ? (currentValue - min) / (max - min) : 0;\n  const percent = Math.min(100, Math.max(0, fraction * 100));\n\n  if (compact) {\n    const sliderText = `${prefix || \"\"}${text}${suffix || \"\"}: ${formatValue(\n      displayValue as number\n    )}`;\n\n    return (\n      <ButtonBase\n        text=\"\"\n        replacedText={true}\n        containerClassName={cn(className, \"h-[20px]\")}\n      >\n        <div className=\"relative w-full h-full flex items-center justify-center\">\n          <div\n            ref={trackRef}\n            role=\"slider\"\n            aria-valuemin={min}\n            aria-valuemax={max}\n            aria-valuenow={displayValue}\n            className=\"absolute inset-0 z-10 cursor-pointer overflow-hidden rounded-[1px] select-none touch-none pointer-events-auto\"\n            onPointerDown={onPointerDown}\n            onPointerMove={(e) => {\n              if (!draggingRef.current) return;\n              setFromClientX(e.clientX);\n            }}\n          >\n            <div\n              className=\"absolute left-0 top-0 h-full bg-[rgb(125,85,255)]\"\n              style={{ width: `${percent}%` }}\n            />\n          </div>\n          <span\n            className={cn(\n              `text-center text-white text-sm truncate z-30 pointer-events-none`,\n              \"select-none\"\n            )}\n            style={{\n              WebkitTextStroke: \"0.1px #000\",\n              WebkitTextFillColor: \"white\",\n              textShadow:\n                \"0 1px 0 #000, 1px 0 0 #000, 0 -1px 0 #000, -1px 0 0 #000\",\n            }}\n          >\n            {sliderText}\n          </span>\n        </div>\n      </ButtonBase>\n    );\n  }\n\n  return (\n    <div className={cn(\"flex flex-col gap-1\", className)}>\n      <Label className=\"text-white opacity-100\">{text}</Label>\n      <div className=\"relative w-full h-[20px] rounded-[1px] bg-[rgb(25,25,25)] border-[rgb(40,40,40)] border\">\n        <div\n          ref={trackRef}\n          role=\"slider\"\n          aria-valuemin={min}\n          aria-valuemax={max}\n          aria-valuenow={displayValue}\n          className=\"absolute inset-0 cursor-pointer overflow-hidden rounded-[1px] select-none touch-none\"\n          onPointerDown={onPointerDown}\n          onPointerMove={(e) => {\n            if (!draggingRef.current) return;\n            setFromClientX(e.clientX);\n          }}\n        >\n          <div className=\"absolute inset-0\" />\n          <div\n            className=\"absolute left-0 top-0 h-full bg-[rgb(125,85,255)]\"\n            style={{ width: `${percent}%` }}\n          />\n        </div>\n        <div className=\"absolute inset-0 flex items-center justify-center pointer-events-none\">\n          <span\n            className=\"text-center text-white text-sm select-none\"\n            style={{\n              WebkitTextStroke: \"0.1px #000\",\n              WebkitTextFillColor: \"white\",\n              textShadow:\n                \"0 1px 0 #000, 1px 0 0 #000, 0 -1px 0 #000, -1px 0 0 #000\",\n            }}\n          >\n            {formatValue(displayValue as number)}/\n            {formatValue(displayMax as number)}\n          </span>\n        </div>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Slider.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Tab.tsx",
      "content": "import type { ReactNode } from \"react\";\n\nexport function TabContainer({ children }: { children: ReactNode }) {\n    return (\n        <div className=\"w-full flex flex-1 flex-col min-h-0 overflow-hidden\">\n            <div className=\"flex flex-row w-full overflow-hidden\" style={{ minHeight: 0 }}>{children}</div>\n        </div>\n    );\n}\n\nexport function TabLeft({ children }: { children: ReactNode }) {\n    return (\n        <div className=\"flex-1 pr-1 overflow-y-scroll no-scrollbar\">\n            {children}\n        </div>\n    );\n}\n\nexport function TabRight({ children }: { children: ReactNode }) {\n    return (\n        <div className=\"flex-1 mr-2 overflow-y-scroll no-scrollbar\">\n            {children}\n        </div>\n    );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Tab.tsx"
    },
    {
      "path": "src/components/obsidian/elements/TabBox.tsx",
      "content": "\"use client\";\n\nimport { useState, useMemo, useEffect } from \"react\";\nimport { ElementParser } from \"../DynamicTab\";\nimport { TabboxTab } from \"../element.types\";\n\nexport default function Tabbox({\n  tabs,\n  scope,\n}: {\n  tabs: { [key: string]: TabboxTab };\n  scope: string;\n}) {\n  const tabNames = useMemo(\n    () =>\n      Object.keys(tabs).sort(\n        (a, b) => (tabs[a]?.order ?? 0) - (tabs[b]?.order ?? 0)\n      ),\n    [tabs]\n  );\n\n  const [activeTab, setActiveTab] = useState(tabNames[0]);\n  const activeTabData = useMemo(() => tabs[activeTab], [tabs, activeTab]);\n  useEffect(() => {\n    if (tabNames.length && (!activeTab || !tabs[activeTab])) {\n      setActiveTab(tabNames[0]);\n    }\n  }, [tabNames, tabs, activeTab]);\n\n  if (tabNames.length === 0) return null;\n  return (\n    <div className=\"mt-1 ml-2 mb-3 rounded-[3px] bg-[rgb(15,15,15)] border border-[rgb(40,40,40)] relative font-normal\">\n      <div className=\"w-full h-[38px] flex flex-row bg-[rgb(15,15,15)]\">\n        {/* Buttons */}\n        <div className=\"flex flex-row items-center w-full border-b border-b-[rgb(40,40,40)]\">\n          {tabNames &&\n            tabNames.map((name) => (\n              <button\n                key={name}\n                onClick={() => setActiveTab(name)}\n                className={`flex-1 h-full text-[13px] ${\n                  activeTab === name\n                    ? \"text-white\"\n                    : \"bg-[rgb(40,40,40)] text-white opacity-50\"\n                }`}\n              >\n                {name}\n              </button>\n            ))}\n        </div>\n      </div>\n\n      {/* Content */}\n      <div className=\"flex flex-col right p-2 gap-2\">\n        {activeTabData?.elements?.map((el) => (\n          <ElementParser\n            key={`${activeTab}-${el.index}`}\n            element={el}\n            stateKeyPrefix={`${scope}:tab:${activeTab}`}\n          />\n        ))}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/TabBox.tsx"
    },
    {
      "path": "src/components/obsidian/elements/Toggle.tsx",
      "content": "\"use client\";\n\nimport { CheckIcon } from \"lucide-react\";\nimport { useEffect, useState } from \"react\";\nimport { useUIValue } from \"../UIStateProvider\";\n\nexport default function Toggle({\n  text,\n  checked,\n  risky,\n  stateKey,\n}: {\n  text: string;\n  checked: boolean;\n  risky: boolean;\n  stateKey?: string;\n}) {\n  const [externalChecked, setExternalChecked] = useUIValue<boolean | undefined>(\n    stateKey,\n    undefined\n  );\n  const [isChecked, setChecked] = useState<boolean>(\n    (externalChecked as boolean | undefined) ?? checked\n  );\n\n  useEffect(() => {\n    if (!stateKey) return;\n    const v = externalChecked;\n    if (typeof v === \"boolean\") setChecked(v);\n  }, [externalChecked, stateKey]);\n\n  return (\n    <div\n      className=\"relative gap-2\"\n      onClick={(e) => {\n        e.preventDefault();\n        const next = !isChecked;\n        setChecked(next);\n        if (stateKey) setExternalChecked(next);\n      }}\n    >\n      <button\n        type=\"button\"\n        className=\"absolute left-0 w-[22px] h-[22px] rounded-[3px] bg-[rgb(25,25,25)] hover:bg-[rgb(35,35,35)] border-[rgb(40,40,40)] border\"\n      >\n        <CheckIcon\n          className={`w-[16px] h-[16px] m-[2px] transition-opacity stroke-white`}\n          style={{ opacity: isChecked == true ? 1 : 0 }}\n        />\n      </button>\n\n      <span\n        className={`ml-[28px] text-left block text-sm select-none transition-opacity`}\n        style={{\n          opacity: isChecked == true ? 0.8 : 0.6,\n          color: risky ? \"var(--color-red-500)\" : \"var(--color-white)\",\n        }}\n      >\n        {text}\n      </span>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/Toggle.tsx"
    },
    {
      "path": "src/components/obsidian/elements/WarningBox.tsx",
      "content": "import Label from \"./Label\";\n\nconst ColorScheme = {\n  [\"Warning\"]: {\n    Background: \"#7f0000\",\n    Border: \"#ff3232\",\n    Title: \"#ff3232\",\n    Text: \"#ffffff\",\n  },\n\n  [\"Normal\"]: {\n    Background: \"#0f0f0f\",\n    Border: \"#282828\",\n    Title: \"#ffffff\",\n    Text: \"#ffffff\",\n  },\n} as const;\n\nconst MAX_HEIGHT_PX = 120;\n\nexport default function ObsidianWarningBox({\n  text,\n  title,\n  isNormal,\n  lockSize,\n  visible,\n}: {\n  text: string;\n  title: string;\n  isNormal: boolean;\n  lockSize: boolean;\n  visible: boolean;\n}) {\n  if (!visible) return null;\n  if (title && title.includes(\"Latest Changelog\")) return null;\n  \n  const scheme = isNormal ? ColorScheme.Normal : ColorScheme.Warning;\n  const role = isNormal ? \"note\" : \"alert\";\n  const ariaLive = isNormal ? \"polite\" : \"assertive\";\n\n  return (\n    <div\n      role={role}\n      aria-live={ariaLive}\n      className=\"w-[calc(100%-20px)] flex flex-col rounded-[3px] m-2.5 px-2 py-1 border\"\n      style={{ backgroundColor: scheme.Background, borderColor: scheme.Border }}\n    >\n      <Label\n        className=\"text-[12px] font-normal select-text\"\n        style={{ color: scheme.Title }}\n      >\n        {title || (isNormal ? \"INFO\" : \"WARNING\")}\n      </Label>\n      <div\n        className={lockSize ? \"overflow-y-auto\" : \"overflow-visible\"}\n        style={lockSize ? { maxHeight: MAX_HEIGHT_PX } : undefined}\n      >\n        <Label className=\"text-[13px] font-normal\">{text}</Label>\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/WarningBox.tsx"
    },
    {
      "path": "src/components/obsidian/elements/addons/AddonContainer.tsx",
      "content": "import type { ReactNode } from \"react\";\n\nexport default function AddonContainer({\n  children,\n  className,\n}: {\n  children?: ReactNode;\n  className?: string;\n}) {\n  return (\n    <div className={className}>\n      <div className=\"absolute right-0 top-1/2 -translate-y-1/2 flex gap-1 items-center pointer-events-auto z-40\">\n        {children}\n      </div>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/addons/AddonContainer.tsx"
    },
    {
      "path": "src/components/obsidian/elements/addons/ColorPicker.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport React from \"react\";\nimport { createPortal } from \"react-dom\";\nimport { Color3 } from \"../../element.types\";\nimport { useUIState } from \"../../UIStateProvider\";\nimport Input from \"../Input\";\nimport Label from \"../Label\";\n\n// color conversion utils //\nconst colorUtils = {\n  toHex: (value: number): string => {\n    const clampedValue = Math.max(0, Math.min(255, Math.round(value)));\n    return clampedValue.toString(16).padStart(2, \"0\");\n  },\n\n  rgbToHex: (color: Color3): string => {\n    const { r, g, b } = color;\n    return `#${colorUtils.toHex(r)}${colorUtils.toHex(g)}${colorUtils.toHex(\n      b\n    )}`;\n  },\n\n  rgbToString: (color: Color3): string => {\n    return `${Math.round(color.r)}, ${Math.round(color.g)}, ${Math.round(\n      color.b\n    )}`;\n  },\n\n  hexToRgb: (hex: string): Color3 | null => {\n    const match = /^#?([0-9a-fA-F]{6})$/.exec(hex.trim());\n    if (!match) return null;\n\n    const value = parseInt(match[1], 16);\n    return {\n      r: (value >> 16) & 0xff,\n      g: (value >> 8) & 0xff,\n      b: value & 0xff,\n    };\n  },\n\n  stringToRgb: (rgbString: string): Color3 | null => {\n    const match = /^(\\d{1,3})\\s*,\\s*(\\d{1,3})\\s*,\\s*(\\d{1,3})$/.exec(\n      rgbString.trim()\n    );\n    if (!match) return null;\n\n    return {\n      r: Math.max(0, Math.min(255, parseInt(match[1], 10))),\n      g: Math.max(0, Math.min(255, parseInt(match[2], 10))),\n      b: Math.max(0, Math.min(255, parseInt(match[3], 10))),\n    };\n  },\n\n  rgbToHsv: (color: Color3) => {\n    const r = color.r / 255;\n    const g = color.g / 255;\n    const b = color.b / 255;\n\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    const delta = max - min;\n\n    let h = 0;\n    if (delta !== 0) {\n      if (max === r) {\n        h = ((g - b) / delta + (g < b ? 6 : 0)) / 6;\n      } else if (max === g) {\n        h = ((b - r) / delta + 2) / 6;\n      } else {\n        h = ((r - g) / delta + 4) / 6;\n      }\n    }\n\n    return {\n      h: Math.round(h * 360),\n      s: max === 0 ? 0 : delta / max,\n      v: max,\n    };\n  },\n\n  hsvToRgb: (h: number, s: number, v: number): Color3 => {\n    const normalizedHue = ((h % 360) + 360) % 360;\n    const c = v * s;\n    const x = c * (1 - Math.abs(((normalizedHue / 60) % 2) - 1));\n    const m = v - c;\n\n    let r = 0,\n      g = 0,\n      b = 0;\n\n    if (normalizedHue < 60) {\n      [r, g, b] = [c, x, 0];\n    } else if (normalizedHue < 120) {\n      [r, g, b] = [x, c, 0];\n    } else if (normalizedHue < 180) {\n      [r, g, b] = [0, c, x];\n    } else if (normalizedHue < 240) {\n      [r, g, b] = [0, x, c];\n    } else if (normalizedHue < 300) {\n      [r, g, b] = [x, 0, c];\n    } else {\n      [r, g, b] = [c, 0, x];\n    }\n\n    return {\n      r: Math.round((r + m) * 255),\n      g: Math.round((g + m) * 255),\n      b: Math.round((b + m) * 255),\n    };\n  },\n};\n\nconst useColorState = (defaultValue: Color3 | null, stateKey?: string) => {\n  const { state, setState } = useUIState();\n\n  const storedColor = React.useMemo(\n    () => (stateKey ? (state[stateKey] as Color3 | undefined) : undefined),\n    [stateKey, state]\n  );\n\n  const initialColor = storedColor ||\n    defaultValue || { r: 255, g: 255, b: 255 };\n  const [color, setColor] = React.useState<Color3>(initialColor);\n  const [hsv, setHsv] = React.useState(() => colorUtils.rgbToHsv(initialColor));\n\n  // Keep refs to current values for drag operations //\n  const colorRef = React.useRef(color);\n  const hsvRef = React.useRef(hsv);\n\n  React.useEffect(() => {\n    colorRef.current = color;\n    hsvRef.current = hsv;\n  }, [color, hsv]);\n\n  const updateFromRgb = React.useCallback(\n    (newColor: Color3, updateUIState = true) => {\n      setColor(newColor);\n      setHsv((prevHsv) => {\n        const newHsv = colorUtils.rgbToHsv(newColor);\n        return newHsv.s === 0 ? { ...newHsv, h: prevHsv.h } : newHsv;\n      });\n\n      if (stateKey && updateUIState) {\n        setState(stateKey, newColor);\n      }\n    },\n    [stateKey, setState]\n  );\n\n  const updateFromHsv = React.useCallback(\n    (newHsv: { h: number; s: number; v: number }, updateUIState = true) => {\n      setHsv(newHsv);\n      const newColor = colorUtils.hsvToRgb(newHsv.h, newHsv.s, newHsv.v);\n      setColor(newColor);\n\n      if (stateKey && updateUIState) {\n        setState(stateKey, newColor);\n      }\n    },\n    [stateKey, setState]\n  );\n\n  const saveCurrentColor = React.useCallback(() => {\n    if (stateKey) {\n      setState(stateKey, colorRef.current);\n    }\n  }, [stateKey, setState]);\n\n  // Sync with stored state - only update if external state changed //\n  React.useEffect(() => {\n    if (stateKey && storedColor) {\n      const isDifferent =\n        storedColor.r !== color.r ||\n        storedColor.g !== color.g ||\n        storedColor.b !== color.b;\n      if (isDifferent) {\n        setColor(storedColor);\n        setHsv(colorUtils.rgbToHsv(storedColor));\n      }\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [stateKey, storedColor]); // dont add color here, it will create an inf loop //\n\n  return {\n    color,\n    hsv,\n    updateFromRgb,\n    updateFromHsv,\n    saveCurrentColor,\n    hexString: colorUtils.rgbToHex(color),\n    rgbString: colorUtils.rgbToString(color),\n  };\n};\n\nconst usePopover = () => {\n  const { state, setState } = useUIState();\n  const localId = React.useId();\n  const [isOpen, setIsOpen] = React.useState(false);\n  const [position, setPosition] = React.useState({ left: 0, top: 0 });\n\n  const openId = state[\"colorPicker:openPopover\"] as string | undefined;\n  const isActive = isOpen && openId === localId;\n\n  const open = React.useCallback(() => {\n    setIsOpen(true);\n    setState(\"colorPicker:openPopover\", localId);\n  }, [localId, setState]);\n\n  const close = React.useCallback(() => {\n    setIsOpen(false);\n    if (openId === localId) {\n      setState(\"colorPicker:openPopover\", \"\");\n    }\n  }, [localId, openId, setState]);\n\n  const toggle = React.useCallback(() => {\n    if (isOpen) close();\n    else open();\n  }, [isOpen, open, close]);\n\n  return {\n    isActive,\n    position,\n    setPosition,\n    open,\n    close,\n    toggle,\n  };\n};\n\nconst usePositioning = (\n  anchorRef: React.RefObject<HTMLButtonElement | null>,\n  isActive: boolean,\n  setPosition: (pos: { left: number; top: number }) => void\n) => {\n  const GAP = 4;\n  const PADDING = 8;\n\n  const updatePosition = React.useCallback(() => {\n    if (!anchorRef.current) return;\n\n    const rect = anchorRef.current.getBoundingClientRect();\n    let left = Math.round(rect.left + window.scrollX);\n    let top = Math.round(rect.bottom + window.scrollY + GAP);\n\n    // Keep within viewport bounds //\n    left = Math.max(\n      PADDING,\n      Math.min(left, window.scrollX + window.innerWidth - PADDING)\n    );\n    top = Math.max(\n      PADDING,\n      Math.min(top, window.scrollY + window.innerHeight - PADDING)\n    );\n\n    setPosition({ left, top });\n  }, [anchorRef, setPosition]);\n\n  React.useEffect(() => {\n    if (!isActive) return;\n\n    const events = [\"resize\", \"scroll\"];\n    events.forEach((event) =>\n      window.addEventListener(event, updatePosition, true)\n    );\n\n    return () => {\n      events.forEach((event) =>\n        window.removeEventListener(event, updatePosition, true)\n      );\n    };\n  }, [isActive, updatePosition]);\n\n  return updatePosition;\n};\n\nconst useDragHandler = () => {\n  const createDragHandler = React.useCallback(\n    (onMove: (x: number, y: number) => void, onEnd?: () => void) =>\n      (e: React.MouseEvent | React.TouchEvent) => {\n        e.preventDefault();\n\n        const handleMove = (ev: MouseEvent | TouchEvent) => {\n          const clientX =\n            ev instanceof TouchEvent ? ev.touches[0]?.clientX : ev.clientX;\n          const clientY =\n            ev instanceof TouchEvent ? ev.touches[0]?.clientY : ev.clientY;\n          if (clientX !== undefined && clientY !== undefined)\n            onMove(clientX, clientY);\n        };\n\n        const handleEnd = () => {\n          document.removeEventListener(\"mousemove\", handleMove);\n          document.removeEventListener(\"mouseup\", handleEnd);\n          document.removeEventListener(\"touchmove\", handleMove);\n          document.removeEventListener(\"touchend\", handleEnd);\n          onEnd?.();\n        };\n\n        document.addEventListener(\"mousemove\", handleMove);\n        document.addEventListener(\"mouseup\", handleEnd);\n        document.addEventListener(\"touchmove\", handleMove, { passive: false });\n        document.addEventListener(\"touchend\", handleEnd, { passive: true });\n\n        // Initial move //\n        const initialX =\n          e instanceof TouchEvent\n            ? e.changedTouches[0]?.clientX\n            : (e.nativeEvent as MouseEvent).clientX;\n        const initialY =\n          e instanceof TouchEvent\n            ? e.changedTouches[0]?.clientY\n            : (e.nativeEvent as MouseEvent).clientY;\n        if (initialX !== undefined && initialY !== undefined)\n          onMove(initialX, initialY);\n      },\n    []\n  );\n\n  return createDragHandler;\n};\n\nexport default function ColorPicker({\n  title,\n  defaultValue,\n  className,\n  stateKey,\n}: {\n  title: string | null;\n  defaultValue: Color3 | null;\n  className?: string;\n  stateKey?: string;\n}) {\n  // references //\n  const rootRef = React.useRef<HTMLDivElement>(null);\n  const anchorRef = React.useRef<HTMLButtonElement>(null);\n  const panelRef = React.useRef<HTMLDivElement>(null);\n  const svRef = React.useRef<HTMLDivElement>(null);\n  const hueRef = React.useRef<HTMLDivElement>(null);\n\n  // state hooks //\n  const {\n    hsv,\n    updateFromRgb,\n    updateFromHsv,\n    saveCurrentColor,\n    hexString,\n    rgbString,\n  } = useColorState(defaultValue, stateKey);\n  const { isActive, position, setPosition, close, toggle } = usePopover();\n  const updatePosition = usePositioning(anchorRef, isActive, setPosition);\n  const createDragHandler = useDragHandler();\n\n  // input handlers //\n  const handleHexInput = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newColor = colorUtils.hexToRgb(e.target.value);\n      if (newColor) updateFromRgb(newColor);\n    },\n    [updateFromRgb]\n  );\n\n  const handleRgbInput = React.useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const newColor = colorUtils.stringToRgb(e.target.value);\n      if (newColor) updateFromRgb(newColor);\n    },\n    [updateFromRgb]\n  );\n\n  // drag handlers //\n  const handleSvDrag = React.useCallback(\n    (clientX: number, clientY: number) => {\n      if (!svRef.current) return;\n\n      const rect = svRef.current.getBoundingClientRect();\n      const s = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));\n      const v = Math.max(\n        0,\n        Math.min(1, 1 - (clientY - rect.top) / rect.height)\n      );\n\n      updateFromHsv({ h: hsv.h, s, v }, false); // don't update UI state during drag //\n    },\n    [hsv.h, updateFromHsv]\n  );\n\n  const handleHueDrag = React.useCallback(\n    (clientX: number, clientY: number) => {\n      if (!hueRef.current) return;\n\n      const rect = hueRef.current.getBoundingClientRect();\n      const normalizedY = Math.max(\n        0,\n        Math.min(1, (clientY - rect.top) / rect.height)\n      );\n      const h = (1 - normalizedY) * 360;\n\n      updateFromHsv({ h, s: hsv.s, v: hsv.v }, false);\n    },\n    [hsv.s, hsv.v, updateFromHsv]\n  );\n\n  const handleDragEnd = React.useCallback(() => {\n    saveCurrentColor();\n  }, [saveCurrentColor]);\n\n  // outside click closing //\n  React.useEffect(() => {\n    if (!isActive) return;\n\n    const handleClickOutside = (e: MouseEvent) => {\n      if (rootRef.current && !rootRef.current.contains(e.target as Node)) {\n        close();\n      }\n    };\n\n    document.addEventListener(\"mousedown\", handleClickOutside);\n    return () => document.removeEventListener(\"mousedown\", handleClickOutside);\n  }, [isActive, close]);\n\n  // position update on open //\n  React.useEffect(() => {\n    if (isActive) {\n      setTimeout(updatePosition, 0);\n    }\n  }, [isActive, updatePosition]);\n\n  // drag handlers //\n  const svDragHandler = createDragHandler(handleSvDrag, handleDragEnd);\n  const hueDragHandler = createDragHandler(handleHueDrag, handleDragEnd);\n\n  return (\n    <div ref={rootRef} className=\"relative pointer-events-auto\">\n      <button\n        type=\"button\"\n        ref={anchorRef}\n        className={cn(\n          \"relative flex justify-center items-center w-[24px] h-[22px] border border-[rgb(40,40,40)] cursor-pointer\",\n          className\n        )}\n        style={{ backgroundColor: `rgb(${rgbString})` }}\n        aria-label=\"Open color picker\"\n        aria-haspopup=\"dialog\"\n        aria-expanded={isActive}\n        onClick={(e) => {\n          e.preventDefault();\n          toggle();\n        }}\n      />\n\n      {isActive &&\n        typeof window !== \"undefined\" &&\n        createPortal(\n          <div onMouseDown={close}>\n            <div\n              ref={panelRef}\n              role=\"dialog\"\n              aria-modal=\"false\"\n              className=\"absolute w-[240px] p-[6px] pt-[2px] bg-[rgb(15,15,15)] border border-[rgb(40,40,40)] origin-top-left scale-[0.8] max-sm:scale-[0.5] md:scale-90 lg:scale-100\"\n              style={{\n                left: position.left,\n                top: position.top,\n                height: title ? \"243px\" : \"223px\",\n              }}\n              onClick={(e) => e.stopPropagation()}\n              onMouseDown={(e) => e.stopPropagation()}\n            >\n              {title && <Label>{title}</Label>}\n\n              <div\n                className=\"mt-1 mb-1 h-[180px] flex items-stretch gap-1 select-none\"\n                onMouseDown={(e) => e.stopPropagation()}\n              >\n                {/* Saturation/Value Panel */}\n                <div\n                  ref={svRef}\n                  className=\"relative w-[240px] border border-[rgb(50,50,50)] cursor-crosshair\"\n                  style={{\n                    background: `\n                    linear-gradient(to top, black, rgba(0,0,0,0)), \n                    linear-gradient(to right, white, hsl(${hsv.h}, 100%, 50%))\n                  `,\n                  }}\n                  onMouseDown={svDragHandler}\n                  onTouchStart={svDragHandler}\n                >\n                  <div\n                    className=\"absolute w-[6px] h-[7px] border border-black rounded-full bg-white box-content pointer-events-none\"\n                    style={{\n                      left: `${hsv.s * 100}%`,\n                      top: `${(1 - hsv.v) * 100}%`,\n                      transform: \"translate(-50%, -50%)\",\n                    }}\n                  />\n                </div>\n\n                {/* Hue Slider */}\n                <div\n                  ref={hueRef}\n                  className=\"relative w-[16px] border border-[rgb(50,50,50)] cursor-pointer\"\n                  style={{\n                    background:\n                      \"linear-gradient(to top, red, yellow, lime, cyan, blue, magenta, red)\",\n                  }}\n                  onMouseDown={hueDragHandler}\n                  onTouchStart={hueDragHandler}\n                >\n                  <div\n                    className=\"absolute left-[-3px] w-[18px] h-[3px] border border-black bg-white pointer-events-none\"\n                    style={{\n                      top: `${(1 - hsv.h / 360) * 100}%`,\n                      transform: \"translateY(-50%)\",\n                    }}\n                  />\n                </div>\n              </div>\n\n              {/* Input Fields */}\n              <div\n                className=\"flex flex-row gap-[7px] h-[26px]\"\n                onMouseDown={(e) => e.stopPropagation()}\n              >\n                <Input\n                  inputClassName=\"text-center text-[12px]\"\n                  text=\"\"\n                  value={hexString}\n                  placeholder=\"#rrggbb\"\n                  onChanged={handleHexInput}\n                />\n                <Input\n                  inputClassName=\"text-center text-[12px]\"\n                  text=\"\"\n                  value={rgbString}\n                  placeholder=\"r, g, b\"\n                  onChanged={handleRgbInput}\n                />\n              </div>\n            </div>\n          </div>,\n          document.body\n        )}\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/addons/ColorPicker.tsx"
    },
    {
      "path": "src/components/obsidian/elements/addons/KeyPicker.tsx",
      "content": "\"use client\";\n\nimport { cn } from \"@/lib/utils\";\nimport Label from \"../Label\";\nimport { useEffect, useState, useMemo } from \"react\";\nimport { useUIState } from \"../../UIStateProvider\";\n\nexport default function KeyPicker({\n  defaultValue,\n  className,\n  stateKey,\n}: {\n  defaultValue: string;\n  className?: string;\n  stateKey?: string;\n}) {\n  const { state, setState } = useUIState();\n\n  const storedValue = useMemo(\n    () => (stateKey ? (state[stateKey] as string | undefined) : undefined),\n    [stateKey, state]\n  );\n  const [value, setValue] = useState<string>(storedValue ?? defaultValue);\n  const [isListening, setIsListening] = useState<boolean>(false);\n\n  useEffect(() => {\n    if (!isListening) return;\n\n    const handleKeyDown = (e: KeyboardEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n\n      const key = e.key;\n      const cleaned = key.length === 1 ? key.toUpperCase() : key;\n\n      setValue(cleaned);\n      if (stateKey) setState(stateKey, cleaned);\n      setIsListening(false);\n    };\n\n    window.addEventListener(\"keydown\", handleKeyDown, { capture: true });\n    return () => {\n      window.removeEventListener(\"keydown\", handleKeyDown, true);\n    };\n  }, [isListening, stateKey, setState]);\n\n  // Sync with UI state when stored value changes //\n  useEffect(() => {\n    if (stateKey && storedValue !== undefined && storedValue !== value) {\n      setValue(storedValue);\n    }\n  }, [stateKey, storedValue, value]);\n\n  return (\n    <div\n      className={cn(\n        \"flex justify-center items-center h-[22px] bg-[rgb(25,25,25)] hover:bg-[rgb(35,35,35)] border-[rgb(40,40,40)] border\",\n        className\n      )}\n      onClick={(e) => {\n        e.preventDefault();\n        setIsListening(true);\n      }}\n      title={isListening ? \"Press a key...\" : undefined}\n    >\n      <Label className=\"m-1 text-[12px] text-white\">\n        {isListening ? \"...\" : value}\n      </Label>\n    </div>\n  );\n}\n",
      "type": "registry:ui",
      "target": "components/obsidian/elements/addons/KeyPicker.tsx"
    }
  ]
}